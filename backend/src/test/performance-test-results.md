# fitquest JUnit 5를 활용한 todo와 activity간 동시성 성능 테스트

## 테스트 개요

본 테스트는 Todo 업데이트와 Activity 조회 간의 동시성 처리 성능을 측정하기 위해 수행되었습니다.

## 테스트 시나리오

실제 서비스 환경을 고려하여 다음과 같은 시나리오로 테스트를 설계했습니다:

### 실제 부하 분석
1500명 * 7개 Todo = 10,500건의 요청에서:

   - Todo 테이블 UPDATE 쿼리: 10,500건
   - Todo 완료율 조회 쿼리: 10,500건
   - Activity 테이블 UPDATE/INSERT 쿼리: 10,500건
   - 총 DB 작업: 31,500건 (10,500 * 3)

### 피크 시간대 동시 사용자 부하 테스트
- 60초의 제한된 시간 내에서 테스트 수행
- 각 사용자는 7개의 Todo를 무작위 시간 간격으로 업데이트
- 사용자별 요청은 0~100ms 사이의 랜덤한 간격으로 발생
- 모든 Todo 업데이트는 Activity 데이터 갱신을 트리거

### 부하 제어
- 60초의 타임윈도우를 활용하여 요청 분산
- 남은 시간에 따른 동적인 요청 간격 조절
- 시간 초과 시 안전한 종료 처리

### 모니터링 지표
- 성공한 요청 수
- 총 소요 시간(초)
- 평균 응답 시간(ms)
- 최대 응답 시간(ms)
- 최소 응답 시간(ms)
- TPS

다음과 같은 단계별 테스트를 통해 시스템의 성능과 확장성을 검증했습니다:

### 1차 테스트

1. 순차 처리 - 100명 동시 사용자(700개의 Todo)
2. 순차 처리 - 250명 동시 사용자(1750개의 Todo)  
3. 순차 처리 - 500명 동시 사용자(3500개의 Todo)

### 2차 테스트
Todo와 Activity 업데이트에 대해 CompletableFuture과 @Async 적용 후 비동기 처리 성능 테스트

1. 비동기 처리 - 500명 동시 사용자(3500개의 Todo)
2. 비동기 처리 - 750명 동시 사용자(5250개의 Todo)
3. 비동기 처리 - 1000명 동시 사용자(7000개의 Todo)

### 3차 테스트
Todo의 업데이트를 큐에 넣고 일정 시간마다 작업 스케줄링으로 Spring이 처리하게 하는 방식으로 성능 테스트

1. 비동기 처리 + 작업 스케줄링 - 1000명 동시 사용자(7000개의 Todo)
2. 비동기 처리 + 작업 스케줄링 - 1250명 동시 사용자(8750개의 Todo)
3. 순차 처리 - 1500명 동시 사용자(10500개의 Todo)
4. 비동기 처리 - 1500명 동시 사용자(10500개의 Todo)
5. 비동기 처리 + 작업 스케줄링 - 1500명 동시 사용자(10500개의 Todo)

## 1차 테스트 결과

| 테스트 케이스 | 동시 사용자 수 | 사용자당 Todo 수 | 총 요청 수 | 성공한 요청 수 | 총 소요 시간(초) | 평균 응답 시간(ms) | 최대 응답 시간(ms) | 최소 응답 시간(ms) | TPS |
|--------------|--------------|----------------|-----------|--------------|----------------|-----------------|-----------------|-----------------|-----|
| 1. 100*7 순차 처리 | 100 | 7 | 700 | 700 | 0.81 | 35.30 | 380 | 4 | 860.0 |
| 2. 250*7 순차 처리 | 250 | 7 | 1750 | 1750 | 1.79 | 124.38 | 1136 | 4 | 978.2 |
| 3. 500*7 순차 처리 | 500 | 7 | 3500 | 3500 | 3.09 | 282.56 | 2341 | 4 | 1132.7 |

### 중간 결론 1

- 사용자 수가 증가할수록 응답 시간이 다소 급격히 증가하는 것을 확인
- 특히 500명 이상의 동시 사용자에서 응답 시간이 2초 이상으로 급격히 증가하는 것을 확인
- 500명 시점부터 비동기 처리 방식 변경 고려

## 2차 테스트 결과

| 테스트 케이스 | 동시 사용자 수 | 사용자당 Todo 수 | 총 요청 수 | 성공한 요청 수 | 총 소요 시간(초) | 평균 응답 시간(ms) | 최대 응답 시간(ms) | 최소 응답 시간(ms) | TPS |
|--------------|--------------|----------------|-----------|--------------|----------------|-----------------|-----------------|-----------------|-----|
| 1. 비동기 처리 - 500명 | 500 | 7 | 3500 | 3500 | 1.71 | 27.50 | 545 | 2 | 2046.8 |
| 2. 비동기 처리 - 750명 | 750 | 7 | 5250 | 5250 | 2.47 | 31.84 | 745 | 2 | 2123.8 |
| 3. 비동기 처리 - 1000명 | 1000 | 7 | 7000 | 7000 | 3.93 | 79.74 | 1577 | 1 | 1780.7 |

### 중간 결론 2
1. 응답 시간 개선
   - 500명 기준 비교
     - 순차: 평균 282.56ms → 비동기: 평균 27.50ms (90.3% 감소)
     - 순차: 최대 2341ms → 비동기: 최대 545ms (76.7% 감소)
   
2. 처리량(TPS) 향상
   - 500명 기준: 1132.7 → 2046.8 (80.7% 증가)
   - 750명까지 TPS 지속 증가 (2123.8)
   - 1000명에서 약간의 성능 저하 but 여전히 순차 처리보다 우수

3. 확장성 개선
   - 750명까지 안정적인 평균 응답 시간 유지 (31.84ms)
   - 1000명에서도 평균 응답 시간 80ms 이하 유지
   - 그러나 여전히 처리량이 많아질 경우 응답 시간이 급격히 증가하는 것을 확인
   - 최대 응답 시간을 개선시킬 필요 있음

## 3차 테스트 결과

| 테스트 케이스 | 동시 사용자 수 | 사용자당 Todo 수 | 총 요청 수 | 성공한 요청 수 | 총 소요 시간(초) | 평균 응답 시간(ms) | 최대 응답 시간(ms) | 최소 응답 시간(ms) | TPS |
|--------------|--------------|----------------|-----------|--------------|----------------|-----------------|-----------------|-----------------|-----|
| 1. 비동기 + 스케줄링 - 1000명 | 1000 | 7 | 7000 | 7000 | 1.63 | 27.56 | 877 | 0 | 4297.1 |
| 2. 비동기 + 스케줄링 - 1250명 | 1250 | 7 | 8750 | 8750 | 2.01 | 10.25 | 328 | 0 | 4353.2 |
| 3. 순차 처리 | 1500 | 7 | 10500 | 10500 | 5.07 | 541.32 | 4033 | 2 | 2071.0 |
| 4. 비동기 처리 | 1500 | 7 | 10500 | 10500 | 3.15 | 20.49 | 676 | 0 | 3333.3 |
| 5. 비동기 + 스케줄링 | 1500 | 7 | 10500 | 10500 | 2.28 | 21.39 | 480 | 0 | 4601.2 |


## 최종 결론

1. 성능 개선 효과
   - 순차 처리 대비 비동기+스케줄링 방식 도입 시:
     - 처리량(TPS) 122% 증가 (2071.0 → 4601.2)
     - 평균 응답시간 96% 감소 (541.32ms → 21.39ms) 
     - 최대 응답시간 88% 감소 (4033ms → 480ms)

2. 확장성 확보
   - 1500명의 동시 사용자도 안정적으로 처리 가능
   - 사용자 수 증가에도 성능 저하 미미
   - 평균 응답시간 20ms대 유지

3. 아키텍처 개선 효과
   - 비동기 처리로 응답성 향상
   - 스케줄링 도입으로 시스템 부하 분산
   - 안정적인 서비스 품질 제공 가능
